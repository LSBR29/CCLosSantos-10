# Estrategias para resolver problemas con algoritmos
## 1. Uso de ciclos

### ¿Qué es?

Es una estrategia que repite acciones paso a paso para revisar datos, tomar decisiones o buscar respuestas.

### ¿Cuándo se usa?

Cuando queremos revisar todos los elementos de una lista, contar cosas, buscar el mayor o menor valor, entre otros.

### Ejemplo: Buscar el número mayor en una lista

```python
numeros = [4, 7, 1, 9, 3]
mayor = numeros[0]

for numero in numeros:
    if numero > mayor:
        mayor = numero

print("Mayor:", mayor)
```

---

## 2. Fuerza bruta (búsqueda exhaustiva)

### ¿Qué es?

Consiste en probar todas las opciones posibles hasta encontrar la respuesta correcta. No es la forma más rápida, pero siempre encuentra la solución.

### ¿Cuándo se usa?

Cuando el problema es pequeño y se necesita probar muchas combinaciones.

### Concepto clave: Permutaciones

Una *permutación* es un reordenamiento de los elementos de un conjunto. Por ejemplo, las permutaciones de \[1, 2] son: \[1, 2] y \[2, 1].

### Ejemplo: Ordenar una palabra hasta llegar a otra

```python
from itertools import permutations

palabra = "sol"
objetivo = "los"

contador = 0
for perm in permutations(palabra):
    contador += 1
    print(perm)

    intento = "".join(perm)
    if intento == objetivo:
        print(f"Encontrado {intento} en el intento #{contador}")
        break
```

---

## 3. Algoritmos voraces (greedy)

### ¿Qué es?

Es una estrategia que toma siempre la mejor decisión en ese momento, con la esperanza de que eso lleve a la mejor solución final.

### ¿Cuándo se usa?

Cuando el problema permite construir una solución eligiendo siempre lo mejor en cada paso, sin necesidad de revisar todas las opciones.

### Ejemplo: Dar cambio con la menor cantidad de monedas

```python
monedas = [100, 50, 25, 10, 5, 1]
monto = 87

for moneda in monedas:
    while monto >= moneda:
        print(f"Usar moneda de {moneda}")
        monto -= moneda
```

Este algoritmo elige siempre la moneda más grande posible.

---

## 4. Divide y vencerás

### ¿Qué es?

Consiste en dividir un problema grande en partes más pequeñas, resolver esas partes y luego combinar las soluciones.

### ¿Cuándo se usa?

Cuando es posible descomponer el problema en subproblemas similares al original.

### Ejemplo: Búsqueda binaria en una lista ordenada

```python
def busqueda_binaria(lista, objetivo):
    izquierda = 0
    derecha = len(lista) - 1

    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2

        if lista[medio] == objetivo:
            return medio
        elif lista[medio] < objetivo:
            izquierda = medio + 1
        else:
            derecha = medio - 1

    return -1

print(busqueda_binaria([1, 3, 5, 7, 9], 5))
```

---

## 5. Vuelta atrás (backtracking)

### ¿Qué es?

Es una estrategia que construye soluciones paso a paso, y si en algún momento nota que no puede continuar, se devuelve y prueba otro camino.

### ¿Cuándo se usa?

Cuando el problema tiene muchas posibles combinaciones, pero solo algunas son válidas.

### Ejemplo: Colocar números sin repetir

```python
def backtrack(n, camino=[]):
    if len(camino) == n:
        print(camino)
        return

    for i in range(1, n + 1):
        if i not in camino:
            backtrack(n, camino + [i])

backtrack(3)
```

Este código genera todas las formas de colocar los números del 1 al 3 sin repetir.

---

## 6. Programación dinámica

### ¿Qué es?

Es una técnica que resuelve problemas grandes recordando las soluciones de problemas pequeños para no repetir cálculos.

### ¿Cuándo se usa?

Cuando un problema se puede dividir en subproblemas que se repiten y sus resultados se pueden reutilizar.

### Ejemplo: Serie de Fibonacci sin repetir cálculos

```python
def fibonacci(n):
    dp = [0, 1]
    for i in range(2, n + 1):
        dp.append(dp[i - 1] + dp[i - 2])
    return dp[n]

print(fibonacci(6))
```

En lugar de volver a calcular los mismos valores, se guardan y se reutilizan (memoización).