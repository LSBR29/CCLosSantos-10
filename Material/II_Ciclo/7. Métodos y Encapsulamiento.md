# Métodos y Encapsulamiento

## Métodos
### Métodos para consultar
No modifican los atributos, solo retornan información.
**Ejemplo:**
```python
class Rectangulo:
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura

    def area(self): # Método para consultar
        return self.base * self.altura

r1 = Rectangulo(5, 10)
print(r1.area())
```

### Métodos para mutar
Cambian el estado de los atributos.
**Ejemplo:**
```python
class Rectangulo:
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura

    def escalar(self, factor): # Método para mutar
        self.base *= factor
        self.altura *= factor

r1 = Rectangulo(5, 10)
print(r1.base)

r1.escalar(2)
print("Escalado:")
print(r1.base)
```

---

## Métodos Especiales
Algunos métodos especiales son:

* `__init__` → inicializa atributos.
* `__str__` → representación legible.
* `__eq__` → igualdad entre objetos.
* `__lt__` → menor que.
* `__gt__` → mayor que.

[Más Métodos Especiales](https://www.netinetidesign.com/post/metodos-especiales-en-python/)

**Ejemplo:**
```python
class Rectangulo:
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura

    def __str__(self):
        return f"El Rectángulo mide {self.base} x {self.altura}"

    def __eq__(self):
        return self.base == other.base

    def __lt__(self):
        return self.base < other.base

    def __gt__(self):
        return self.base > other.base


r1 = Rectangulo(5, 10)
r2 = Rectangulo(15, 20)

print(r1)
print(r2)

print(r1 == r2)
print(r1 < r2)
print(r1 > r2)
```

---

## Encapsulamiento

Principio de la POO que:

* Oculta detalles internos de la clase.
* Protege la integridad de los datos.
* Valida valores antes de asignarlos.
* Facilita cambios internos.

### Tipos de atributos

* **Público:** `atributo`
* **Protegido (convención):** `_atributo`
* **Privado:** `__atributo`

**Ejemplo:**
```python
class Estudiante:
    def __init__(self, nombre, nota):
        self.nombre = nombre     # público
        self._nota = nota        # protegido
        self.__codigo = "12345"  # privado

e1 = Estudiante("Carlos", 98)
print(e1.nombre)
print(e1._nota)
print(e1.__codigo)
```

---

## Getters y Setters

### Forma tradicional

Se usan métodos que retornan o modifican atributos privados.

**Ejemplo:**

```python
class Estudiante:
    def __init__(self, nota):
        self.__nota = nota

    def get_nota(self):
        return self.__nota

    def set_nota(self, nueva_nota):
        self.__nota = nueva_nota

e1 = Estudiante(72)
print(e1.get_nota())
e1.set_nota(98)
print(e1.get_nota())
```

---

### Uso de @property y @atributo.setter

Convierte métodos en atributos, más intuitivo y fácil de usar.

**Ejemplo:**

```python
class Estudiante:
    def __init__(self, nota):
        self.__nota = nota

    @property
    def nota(self):
        return self.__nota

    @nota.setter
    def nota(self, nueva_nota):
        self.__nota = nueva_nota

e1 = Estudiante(72)
print(e1.nota)
e1.nota = 98
print(e1.nota)
```

---

## Diferencias

| Aspecto       | Tradicional (`get_`, `set_`)         | Con `@property`             |
| ------------- | ------------------------------------ | --------------------------- |
| Sintaxis      | `obj.get_nota()`, `obj.set_nota(95)` | `obj.nota`, `obj.nota = 95` |
| Legibilidad   | Menos natural                        | Más limpio y modeno         |
| Transparencia | Se ve que son métodos                | Parece acceso directo       |
