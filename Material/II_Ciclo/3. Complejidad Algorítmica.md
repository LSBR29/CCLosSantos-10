# Complejidad Temporal y Espacial - Notación Big O
## ¿Qué es la complejidad algorítmica?

Es la forma de medir cuánto tiempo tarda un programa (complejidad temporal) o cuánta memoria usa (complejidad espacial) a medida que crece el tamaño de la entrada.

**Ejemplo:**  
Contar libros en un estante:
- 10 libros → poco tiempo
- 100 libros → más tiempo
- 1000 libros → mucho más tiempo

La complejidad permite comparar la eficiencia de diferentes algoritmos.

## Notación Big O

Big O describe el comportamiento de crecimiento de un algoritmo en el peor caso.

## Complejidades temporales comunes

| Complejidad | Nombre              | Ejemplo típico                          |
|-------------|---------------------|-----------------------------------------|
| O(1)        | Constante           | Acceso a un elemento de un array        |
| O(log n)    | Logarítmica         | Búsqueda binaria                        |
| O(√n)       | Raíz cuadrada       | Comprobar si un número es primo         |
| O(n)        | Lineal              | Recorrer una lista                      |
| O(n log n)  | Lineal-logarítmica  | Merge sort, Quick sort                  |
| O(n²)       | Cuadrática          | Dos bucles anidados                     |
| O(2^n)      | Exponencial         | Fuerza bruta                            |
| O(n!)       | Factorial           | Generar permutaciones                   |

### Explicaciones y ejemplos

#### O(1) - Constante
El tiempo no depende del tamaño de la entrada.
```python
primer_elemento = lista[0]
```

#### O(log n) - Logarítmica
Cada paso reduce el problema a la mitad.
```python
def busqueda_binaria(lista, objetivo):
    izquierda, derecha = 0, len(lista)-1
    while izquierda <= derecha:
        medio = (izquierda + derecha) // 2
        if lista[medio] == objetivo:
            return medio
        elif lista[medio] < objetivo:
            izquierda = medio + 1
        else:
            derecha = medio - 1
    return -1
```

#### O(√n) - Raíz cuadrada
Cuando se realizan √n operaciones, como en tests de primalidad.
```python
def es_primo(n):
    if n < 2: 
        return False

    for i in range(2, int(n**0.5) + 1):  # Hasta la raíz cuadrada
        if n % i == 0:
            return False

    return True
```

#### O(n) - Lineal
Tiempo lineal, el tiempo aumenta igual a la cantidad de datos.
```python
for elemento in lista:
    print(elemento)
```

#### O(n log n) - Lineal-logarítmica
Común en algoritmos de ordenamiento.
```python
# Merge sort
```

#### O(n²) - Cuadrática
Típico de dos bucles anidados, se realizan n operaciones para el primer bucle y n operaciones para el segundo.
```python
for i in range(n):
    for j in range(n):
        print(i, j)
```

#### O(2^n) - Exponencial
El tiempo se duplica con cada elemento.
```python
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)
```

#### O(n!) - Factorial
Crecimiento extremadamente rápido, probar todas las opciones para un mismo dato.
```python
import itertools
permutaciones = list(itertools.permutations([1,2,3]))
```

## Complejidad espacial

Mide la memoria utilizada por un algoritmo.

| Complejidad espacial | Ejemplo típico                      |
|----------------------|-------------------------------------|
| O(1)                 | Variables fijas                     |
| O(n)                 | Almacenar una lista de n elementos  |
| O(n²)                | Matriz de n x n                     |

**Ejemplo:**
```python
# O(1) espacio
a = 1
b = 2

# O(n) espacio
lista = [i for i in range(n)]
# [1, 2, 3, 4]

# O(n²) espacio
i = [0]*n
matriz = [i for i in range(n)]
"""
[[0, 0, 0, 0]
 [0, 0, 0, 0]
 [0, 0, 0, 0]
 [0, 0, 0, 0]]
"""
```

## Cómo determinar la complejidad

1. **Identificar bucles:**
   - Un bucle: O(n)
   - Dos bucles anidados: O(n²)
   - Bucle que divide el problema: O(log n)

2. **Llamadas recursivas:**
   - Recursión simple: O(n)
   - Recursión con múltiples llamadas: O(2^n) o O(n!)

3. **Ignorar constantes:**
   - O(2n) → O(n)
   - O(n² + n) → O(n²)

## Ejercicios

1. ¿Complejidad temporal?
```python
for i in range(n):
    for j in range(10):
        print(i*j)
```
**Respuesta:** O(n)

2. Mejorar de O(n²) a O(n):
```python
# Original (O(n²))
def duplicados(lista):
    for i in range(len(lista)):
        for j in range(i+1, len(lista)):
            if lista[i] == lista[j]:
                return True
    return False

# Mejorado (O(n))
def duplicados_mejorado(lista):
    visto = []
    for elemento in lista:
        if elemento in visto:
            return True
        visto.append(elemento)
    return False
```

3. Complejidad espacial de:
```python
def factorial(n):
    if n <= 1:
        return 1
        
    return n * factorial(n-1)
```
**Respuesta:** O(n)